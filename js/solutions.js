// Problem #1
// If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
// Find the sum of all the multiples of 3 or 5 below 1000.

// Really simple for loop, goes without any further explanation I suppose.

function problem1(nr) {
	var sum = 0;
	for( i = 0; i < nr; i++ ) {
		if( i % 3 === 0 || i % 5 === 0 ) {
			sum += i;
		}
	}
	return sum;
}

// Problem #2
// Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
// 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
// By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.

function problem2(max) {
	var sum = 0;
	
	// Starting out with an array with the two starting values of the Fibonnaci sequence
	fibArray = new Array(1, 1);
	
	// Run the while as long as the one-before-last value is under 4 million
	while( fibArray[ fibArray.length - 1 ] < max ) {
	
		// Add the sum of the last two array items to the end of the array
		fibArray.push( fibArray[ fibArray.length - 1 ] + fibArray[ fibArray.length - 2 ] );
	}
	
	// The problem requires we only find the sum of the even-valued terms, so we need to go over the array and add the even ones to sum
	for( i = 0; i < fibArray.length; i++ ) {
		if ( fibArray[i] % 2 === 0) {
			sum += fibArray[i];
		}
	}
	
	return sum;
}

// Problem #3
// The prime factors of 13195 are 5, 7, 13 and 29.
// What is the largest prime factor of the number 600851475143 ?

function problem3(nr) {
			
	// Define a new array to store prime factors
	var array = new Array();
	
	for( i = 2; i <= nr; i++ ){
		
		// Check if nr can be divided by i with no remainder
		if( nr % i == 0 ){
			
			// If so, reassign nr to nr / i and push i to the array
			nr = nr / i;
			array.push(i);
		}
	}
	
	// Return the largest prime factor in the array, which is the last in the array
	return array[ array.length - 1 ];
}

// Problem #4
// A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 99.
// Find the largest palindrome made from the product of two 3-digit numbers.

// Helper function for reversing strings/numbers
function reverse(string) {
	// Split the string into an array
	splitArray = string.split("");
	
	// Reverse the array
	splitArray = splitArray.reverse();
	
	// Join the array back to a string, no delimiter
	reversedString = splitArray.join("");
	
	// Return the reversed String
	return reversedString;
}

function problem4() {
	var answer = 0;
	
	// Start at 100, count up to 999
	for( i = 100; i < 1000; i++ ) {
	
		// Same, start at 100 and count up to 999
		for( j = 100; j < 1000; j++ ) {
			
			// temporarily store product of i and j
			var temp = i * j;
							
			// Check if temp is the same forwards as backwards
			if ( temp.toString() == reverse( temp.toString() ) ) {
				// Check if it's larger than variable answer and store it if it is
				if ( temp > answer ) {
					answer = temp;
				}					
			}
		}
	}
	return answer;
}

// Problem #5
// 2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.
// What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?

// There's two ways to do this: Easy dirty or "complex" and neat

// The easy way would be cheesing it by simply running a for loop and checking modulos 11 through 20 untill we've found a number that gets through it all
// However, a faster way is by using maths, the Least Common Multiple(LCM) and Greatest Common Divisor(GCD).

function gcd(a, b) { 
	// Formula for GCD
	return ( b == 0 ) ? (a):( gcd(b, a % b) ); 
}

function lcm(a, b) { 
	// Formula for LCM
	return ( a * b / gcd(a, b) ); 
}

// Putting it all together
// This function will continually call itself untill there's only one item left in the array.
// It takes the top pair and gets the LCM from them, using the lcm function above, and puts it at the end of the array
// Using pop(), it ensures no numbers are processed more than once
		
function problem5(numbers) {
	if (numbers.length > 1) {
		numbers.push( lcm( numbers.pop(), numbers.pop() ) );
		return problem5( numbers );
	} else {
		return numbers[0];
	}
}

// Problem #6
// The sum of the squares of the first ten natural numbers is,
//     1 + 2 + ... + 10 = 385
// The square of the sum of the first ten natural numbers is,
//     (1 + 2 + ... + 10) = 55 = 3025
// Hence the difference between the sum of the squares of the first
// ten natural numbers and the square of the sum is 3025 - 385 = 2640.
//
// Find the difference between the sum of the squares of the first one
// hundred natural numbers and the square of the sum.

function problem6(number, power) {
	var sumSquares = 0;
	var squareSum = 0;
	
	for( i = 1; i <= number; i++ ) {
		sumSquares += Math.pow(i, power);
		squareSum += i; // We'll square this later; saves another for loop adding it now
	}
	
	squareSum = Math.pow(squareSum, power);
	return squareSum - sumSquares;
}